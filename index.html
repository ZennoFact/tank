<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>M_Tank</title>
  <style>
    * {
      margin: 0;
    }

    #map {
      position: absolute;
      width: 150px;
      height: 150px;
      top: 20px;
      right: 20px;
      background-color: #646464;
      border: solid 2px #000000;
    }
  </style>
</head>
<body>
  <script src="./js/vendor/three.js"></script>
  <script src="./js/vendor/OBJLoader.js"></script>
  <script src="./js/bear.js"></script>
  <script>
    const scene = new THREE.Scene();
    let isEditMode = false;
    let isFPSMode = false;

    const cameraBaseHeight = 20;
    const cameraEditHeight = 70;

    // DEBUG
    const gridHelper = new THREE.GridHelper(1000, 1000);
    gridHelper.position.y = 1;
    // scene.add(gridHqelper);

    const ambientLight = new THREE.AmbientLight( 0x242424 );
		scene.add(ambientLight);

    scene.background = new THREE.Color( 0x000000 );
    const renderer = new THREE.WebGLRenderer({
        alpha: true
    });
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );
    
    const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 10000 );
    camera.position.set(0, cameraBaseHeight, 0);
    camera.lookAt(new THREE.Vector3(0,0,0));
    scene.add(camera);


    const mapRenderer = new THREE.WebGLRenderer({
        alpha: true
    });
    mapRenderer.setSize( window.innerWidth, window.innerHeight );
    mapRenderer.domElement.id = 'map';
    mapRenderer.domElement.style.width = "250px";
    mapRenderer.domElement.style.height = "250px";
    document.body.appendChild( mapRenderer.domElement );

    const mapCamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 10000 );
    mapCamera.position.set(0, 30, 0);
    mapCamera.lookAt(new THREE.Vector3(0, 0, 0));
    scene.add(mapCamera);

    // wall
    // const cube = new THREE.Mesh( new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: 0xcc6464 } ) );
    // cube.position.set(1.5, 1, -1.5);

    const cube = new Block({x:1.5, y: 1, z: -1.5});
    scene.add( cube.mesh );
    let cubes = [];
    cubes.push(cube);

    // player
    const geometry = new THREE.BoxGeometry( 1, 1, 2 );
    const material = new THREE.MeshBasicMaterial( { color: 0x555749 } );
    const player = new THREE.Mesh( geometry, material );
    player.position.set(0, 1, 0);
    player.castShadow = true;
    player.receiveShadow = true;
    scene.add( player );

    let playerBB = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());
    playerBB.setFromObject(player);


    // map
    const ground = new THREE.Mesh( new THREE.PlaneGeometry(100,100), new THREE.MeshBasicMaterial({
      color: 0xdddddd
    }));
    ground.receiveShadow = true;
    ground.rotation.x = Math.PI / -2;
    scene.add( ground );

    camera.position.z = 5;

    const state = {
      goForward: false,
      turnLeft: false,
      turnRight: false,
      goBack: false
    };


    function animate() {
      requestAnimationFrame( animate );
      
      if(state.goForward) player.translateZ(-0.1);
      if(state.turnLeft) player.rotation.y += 0.01;
      if(state.goBack) player.translateZ(0.1);
      if(state.turnRight) player.rotation.y -= 0.01;

      // cube.collision(player);

      playerBB.copy(player.geometry.boundingBox).applyMatrix4(player.matrixWorld);
      cubes.forEach(cube => {
        checkCollisions(cube);
      })

      camera.position.x = player.position.x;
      camera.position.z = player.position.z;
      mapCamera.position.x = player.position.x;
      mapCamera.position.z = player.position.z;
      if (isFPSMode) {
        camera.rotation.y = player.rotation.y;
      } else {
        camera.lookAt(player.position);
      }

      renderer.render( scene, camera );
      mapRenderer.render( scene, mapCamera);
    }
    

    animate();

    function checkCollisions(cube) {
      cube.boundingBox.copy(cube.mesh.geometry.boundingBox).applyMatrix4(cube.mesh.matrixWorld);    
      if (cube.boundingBox.intersectsBox(playerBB)) {
        cube.mesh.material.color.setHex(cube.collisionColor);
      } else {
        cube.mesh.material.color.setHex(cube.color);
      }

      // TODO: 完全に重なったら？いる？今のところ要らない

      if (cube.boundingBox.containsBox(playerBB)) {
        cube.mesh.position.y = 3;
      } else {
        cube.mesh.position.y = 1;
      }
    }



    window.addEventListener('keydown', (event) => {
      if (isEditMode) return; // Editモードでは動かさない。

      switch(event.key) {
        case 'w' :
          state.goForward = true;
          break;
        case 'a' :
          state.turnLeft = true;
          break;
        case 's' :
          state.goBack = true;
          break;
        case 'd' :
        case 'e' : // TODO: debug
          state.turnRight = true;
          break;
      }
    }, false);
    window.addEventListener('keyup', (event) => {
      switch(event.key) {
        case 'w' :
          state.goForward = false;
          break;
        case 'a' :
          state.turnLeft = false;
          break;
        case 's' :
          state.goBack = false;
          break;
        case 'd' :
        case 'e' : // TODO: debug
          state.turnRight = false;
          break;
        case 'q':
          if(isEditMode) {
            isEditMode = false;
            camera.position.y = cameraBaseHeight;
          } else if(!isFPSMode && !isFPSMode) { 
            isEditMode = true
            camera.position.y = cameraEditHeight;
          }
          break;
        case ' ': // TODO: 本来はe（Edit）を使いたい
        if(isFPSMode) {
            isFPSMode = false;
            camera.position.y = cameraBaseHeight;
          } else { 
            isFPSMode = true;
            camera.position.y = player.position.y;
            camera.lookAt(0, 1, -3);
            camera.rotation.y = player.rotation.y;
          }
          break;
      }
    }, false);




    const raycaster = new THREE.Raycaster();
    window.addEventListener('click', (event) => {
      clickHandler();
    }, false);

    function clickHandler() {
      if(!isEditMode) return;
      // レイキャスト = マウス位置からまっすぐに伸びる光線ベクトルを生成
      raycaster.setFromCamera(mouse, camera);

      // その光線とぶつかったオブジェクトを得る
      const intersects = raycaster.intersectObjects(scene.children);

      if(intersects.length > 0){
        const point = intersects[0].point;
      
        // Grid上に置くため，四捨五入しておく
        const x = Math.round(point.x);
        const z = Math.round(point.z);
        // console.log(`${x}, ${z}`);
        const cube = new Block({x: x, y: 1, z: z});
        scene.add( cube.mesh );
        cubes.push(cube);
      }
    }


    let isDrag = false;
    window.addEventListener('mousedown', event => {
      isDrag = true;
    }, false)

    window.addEventListener('mouseup', event => {
      isDrag = false;
    }, false)

    // canvas 要素の参照を取得する
    const canvas = document.querySelector('canvas');
    // マウス座標管理用のベクトルを作成
    const mouse = new THREE.Vector2();
    canvas.addEventListener('mousemove', (event) => {
      const element = event.currentTarget;
      // canvas要素上のXY座標
      const x = event.clientX - element.offsetLeft;
      const y = event.clientY - element.offsetTop;
      // canvas要素の幅・高さ
      const w = element.offsetWidth;
      const h = element.offsetHeight;

      // -1〜+1の範囲で現在のマウス座標を登録する
      mouse.x = ( x / w ) * 2 - 1;
      mouse.y = -( y / h ) * 2 + 1;

      if (isDrag) {
        clickHandler();
      }
    }, false);


    // TODO:camera切り替え後のFPSモード進行方向変更のずれを直す

  </script>
</body>
</html>