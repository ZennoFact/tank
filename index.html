<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>M_Cube</title>
  <style>
    * {
      margin: 0;
    }

    #map {
      position: absolute;
      width: 150px;
      height: 150px;
      top: 20px;
      right: 20px;
      background-color: #646464;
      border: solid 2px #000000;
    }
  </style>
</head>
<body>
  <script src="./js/vendor/three.js"></script>
  <script src="./js/vendor/OBJLoader.js"></script>
  <script src="./js/bear.js"></script>
  <script>
    const scene = new THREE.Scene();
    scene.background = new THREE.Color( 0x000000 );
    const floorY = 0.5;

    const lineMaterial = new THREE.LineBasicMaterial({color: 0x6464ff});
    let balls = [];
    const points = [];
    const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
    const line = new THREE.Line(lineGeometry, lineMaterial);
    scene.add(line);

    // どのキーで何の操作をするかを決定 キーコンフィグができるようにしておくよ！
    const action = {
      foward: 'w',
      left: 'a',
      right: 'd',
      back: 's',
      shoot: ' ',
      edit: 'e', // Step.4 エディットモード解禁 case 'e':
      fps: 'q', // TODO: 本来はfが望ましい？
      none: ''
    };
    const cubes = [];
    let isEditMode = false;
    let isFPSMode = false;

    const cameraBaseHeight = 20;
    const cameraEditHeight = 70;

    // DEBUG
    const gridHelper = new THREE.GridHelper(1000, 1000);
    gridHelper.position.y = 1;
    // scene.add(gridHqelper);

    // ライトを付けます
    const ambientLight = new THREE.AmbientLight( 0x242424 );
		scene.add(ambientLight);
    
    // 描画用の部品を作って
    const renderer = new THREE.WebGLRenderer({
        alpha: true
    });
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement ); // 画面に部品を登録します
    
    // カメラを作って
    const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 10000 );
    camera.position.set(0, cameraBaseHeight, 0); // カメラを上（y方向）に飛ばして
    camera.lookAt(new THREE.Vector3(0,0,0)); // 下（原点）を見る
    scene.add(camera); // シーンに登録します

    // マップを描画するための部品を作って
    const mapRenderer = new THREE.WebGLRenderer({
        alpha: true
    });
    mapRenderer.setSize( window.innerWidth, window.innerHeight );
    mapRenderer.domElement.id = 'map';
    // Step.5 画面に部品を登録します　document.body.appendChild( mapRenderer.domElement );
    document.body.appendChild( mapRenderer.domElement ); 

    mapRenderer.domElement.style.width = "250px"; // マップを表示するパーツなのでちっさくしましょう
    mapRenderer.domElement.style.height = "250px";

    // マップを表示するためのカメラも作って
    const mapCamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 10000 );
    mapCamera.position.set(0, 30, 0);
    mapCamera.lookAt(new THREE.Vector3(0, 0, 0));
    scene.add(mapCamera); // シーンに登録しよう


    const cubesFlag = [];
    for (let i = 0; i <= 100; i++) {
      const array = [];
      for (let j = 0; j <= 100; j++) {
        array.push(false);
      }
      cubesFlag.push(array);
    }

    // player
    const geometry = new THREE.BoxGeometry( 0.8, 0.8, 1.6 ); // 形状の指定
    const material = new THREE.MeshBasicMaterial( { color: 0x555749 } ); // 表面の素材を指定（テクスチャ―もこれ
    const player = new THREE.Mesh( geometry, material ); // ポリゴンメッシュ（略してメッシュ）。多角形の面の集合体
    player.position.set(0, floorY, 0); // 位置を決めてー
    player.castShadow = true; // 影を出すようにしてー
    player.receiveShadow = true; // 影を受けるようにして―
    // Step.1 シーンに追加する scene.add( player );
    scene.add( player );  

    let playerBB = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3()); // 接触判定用のBoundingBox（輪郭の箱）を用意
    playerBB.setFromObject(player);  // BoundingBoxとMeshと紐づける！


    // wall 作ろうかと思ったけど，まあいっか

    // sample cube
    const cube = new Block({x:2, y: floorY, z: -2}); // オリジナルのCubeを作る呪文
    cubesFlag[48][52] = true; // cubeがその位置に登録されているかどうかどうかの設定
    cubes.push(cube);
    // Step.2 作ったらシーンにcubeのメッシュを登録しよう
    scene.add( cube.mesh );

    // Floor　床（平面）を作ろう
    const ground = new THREE.Mesh( new THREE.PlaneGeometry(100,100), new THREE.MeshBasicMaterial({
      color: 0xdddddd,
      side: THREE.DoubleSide
    }));
    ground.receiveShadow = true;
    ground.rotation.x = Math.PI / -2; // 平面を作ると縦に出来上がるので，回転させて床にする（なお，三角関数を利用）
    scene.add( ground ); // やっぱりシーンに追加する

    // 今どこに進もうとしているかを記録しておく
    const state = {
      goForward: false,
      turnLeft: false,
      turnRight: false,
      goBack: false
    };

    // 動いた時に線を描きたい場合は呼び出す関数
    function drawLine() {
      points.push(new THREE.Vector3(player.position.x, player.position.y, player.position.z));
      line.geometry = new THREE.BufferGeometry().setFromPoints(points)
    }


    function animate() {
      requestAnimationFrame( animate );
      
      // 動くようにしているところはここ
      if(state.goForward) {
        player.translateZ(-0.1);

        // Step.8-1 移動して線を描きたい
        drawLine();
      }
      if(state.turnLeft) player.rotation.y += 0.01;
      if(state.goBack) {
        player.translateZ(0.1);
        
        // Step.8-2 バックしても線を描きたい
        drawLine();
      }
      if(state.turnRight) player.rotation.y -= 0.01;

      // 床の範囲を越えたら重力の影響を受けます。
      if(player.position.x < -50 || 50 < player.position.x || player.position.z < -50 || 50 < player.position.z) {
        player.position.y -= 0.98;
      }

      playerBB.copy(player.geometry.boundingBox).applyMatrix4(player.matrixWorld); // 動くたびにバウンディングボックスをコピー
      cubes.forEach(cube => { // 一つ一つのキューブを取り出して，
        // Step.6 衝突の検知 cube.collision(playerBB);
        cube.collision(playerBB);
      })

      camera.position.x = player.position.x;
      camera.position.z = player.position.z;
      mapCamera.position.x = player.position.x;
      mapCamera.position.z = player.position.z;
      if (isFPSMode) {
        // TODO: この辺ちょっと挙動が怪しい
        camera.rotation.y = player.rotation.y;
        camera.position.y = player.position.y;
      } else {
        camera.rotation.y = 0;
        camera.lookAt(player.position);
      }

      balls.forEach((ball, i) =>{
        ball.move();
        cubes.forEach(cube => { ball.collision(cube) });
        
        if(!ball.isNotHit) {
          balls.splice(i, 1);
          scene.remove(ball.mesh);
          ball.mesh.material.dispose();
          ball.mesh.geometry.dispose();
        }
      });
      balls = balls.filter(b => b.isNotHit);

      renderer.render( scene, camera );
      mapRenderer.render( scene, mapCamera);
    }
    
    // 一瞬一瞬，再描画し続ける
    animate();


    window.addEventListener('keydown', (event) => {
      // console.log(event.key)
      if (isEditMode) return; // Editモードでは動かさない。
      // Step.3 event.key 押されたキーに応じて分岐する，と動くようになる
      switch(event.key) {
        case action.foward:
        case 'ArrowUp':
          state.goForward = true;
          break;
        case action.left:
        case 'ArrowLeft':
          state.turnLeft = true;
          break;
        case action.back:
        case 'ArrowDown':
          state.goBack = true;
          break;
          case action.right:
          case 'ArrowRight':
          state.turnRight = true;
          break;
        case action.shoot: // 弾丸の発射
          if(!isEditMode) {

          }
          break;
      }
    }, false);

    function notMove() {
      if(state.goForward || state.turnLeft || state.turnRight || state.goBack) return false;
      return true;
    }
    
    window.addEventListener('keyup', (event) => {
      switch(event.key) {
        case action.foward:
        case 'ArrowUp':
          state.goForward = false;
          break;
        case action.left:
        case 'ArrowLeft':
          state.turnLeft = false;
          break;
        case action.back:
        case 'ArrowDown':
          state.goBack = false;
          break;
        case action.right:
        case 'ArrowRight':
          state.turnRight = false;
          break;
        case action.edit:
          if(isEditMode) {
            isEditMode = false;
            camera.position.y = cameraBaseHeight;
          } else if(!isFPSMode && !isEditMode && notMove()) { 
            isEditMode = true
            camera.position.y = cameraEditHeight;
          } 
          break;
        case action.fps: // 視点変更
          if(isFPSMode) {
            isFPSMode = false;
            camera.position.y = cameraBaseHeight;
          } else if(!isEditMode) { 
            isFPSMode = true;
            camera.position.y = player.position.y;
            camera.lookAt(0, floorY, -3);
            camera.rotation.y = player.rotation.y;
          }
          break;
        case action.shoot: // 弾丸の発射
          if(!isEditMode) {
            // Step.7 ボールを投げる！ throwing();
            throwing(); 
          }
          break;
      }
    }, false);

    function throwing() {
      const ball = new Ball(player); // オリジナルのCubeを作る呪文
      scene.add( ball.mesh );
      balls.push(ball);
    }

    const raycaster = new THREE.Raycaster();
    window.addEventListener('click', (event) => {
      clickHandler((mesh, x, z) => {
        scene.remove(mesh);
        mesh.material.dispose();
        mesh.geometry.dispose();

        cubesFlag[z][x] = false;
      });
    }, false);

    function clickHandler(meshClear) {
      if(!isEditMode) return;
      // レイキャスト = マウス位置からまっすぐに伸びる光線ベクトルを生成
      raycaster.setFromCamera(mouse, camera);

      // その光線とぶつかったオブジェクトを得る
      const intersects = raycaster.intersectObjects(scene.children);

      if(intersects.length > 0){
        const point = intersects[0].point;
      
        // Grid上に置くため，四捨五入しておく
        const x = Math.round(point.x);
        const z = Math.round(point.z);

        // TODO: x + 50とか避けて変数に。
        if(cubesFlag[z + 50][x + 50]) {
          // meshがあったら削除
          meshClear(intersects[0].object, x + 50, z + 50);
          return;
        }

        cubesFlag[z + 50][x + 50] = true;

        // console.log(`${x}, ${z}`);
        const cube = new Block({x: x, y: floorY, z: z});
        scene.add( cube.mesh );
        cubes.push(cube);
      }
    }


    let isDrag = false;
    window.addEventListener('mousedown', event => {
      isDrag = true;
    }, false)

    window.addEventListener('mouseup', event => {
      isDrag = false;
    }, false)

    // canvas 要素の参照を取得する
    const canvas = document.querySelector('canvas');
    // マウス座標管理用のベクトルを作成
    const mouse = new THREE.Vector2();
    canvas.addEventListener('mousemove', (event) => {
      const element = event.currentTarget;
      // canvas要素上のXY座標
      const x = event.clientX - element.offsetLeft;
      const y = event.clientY - element.offsetTop;
      // canvas要素の幅・高さ
      const w = element.offsetWidth;
      const h = element.offsetHeight;

      // -1〜+1の範囲で現在のマウス座標を登録する
      mouse.x = ( x / w ) * 2 - 1;
      mouse.y = -( y / h ) * 2 + 1;

      if (isDrag) {
        clickHandler(() => {});
      }
    }, false);


    // TODO:camera切り替え後のFPSモード進行方向変更のずれを直す

  </script>
</body>
</html>