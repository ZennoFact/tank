<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>M_Cube</title>
  <link rel="stylesheet" href="./assets/css/style.css">
</head>
<body>
  <template id="uiParts">
    <div id="rTriger" class="ui">
      <h2>Main</h2>
      <p>R-Triger</p>
    </div>
    <div id="rButton" class="ui">
      <h2>Sub</h2>
      <p>R-Button</p>
    </div>
    <div id="dive" class="ui">
      <h2>Dive</h2>
      <p>L-Triger</p>
    </div>
    <div id="color" class="ui">
      <h2>Color: <span class="color">6464ff</span></h2>
    </div>
    <div id="lStick" class="ui">
      <h2>Move</h2>
      <p>↑L-Stick↓</p>
    </div>
    <div id="rStick" class="ui">
      <h2>Roll</h2>
      <p>←R-Stick→</p>
    </div>
    <div id="view" class="ui">
      <h2 class="mode">Bird's Eye</h2><p class="parts">R-Stick Press</p>
    </div>
  </template>
  <script src="./js/vendor/three.js"></script>
  <script src="./js/vendor/OBJLoader.js"></script>
  <script src="./js/config.js"></script>
  <script src="./js/bear.js"></script>
  <script src="./js/ui.js"></script>
  <script>
    const scene = new THREE.Scene();
    scene.background = new THREE.Color( 0x000000 );
    const floorY = 0.5;

    // 今
    const lineMaterial = new THREE.LineBasicMaterial({color: 0x6464ff});
    let balls = [];
    let padList = [];
    const points = [];
    const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
    const line = new THREE.Line(lineGeometry, lineMaterial);
    scene.add(line);

    let cubes = [];
    const cubesFlag = [];
    for (let i = 0; i <= 100; i++) {
      const array = [];
      for (let j = 0; j <= 100; j++) {
        array.push(false);
      }
      cubesFlag.push(array);
    }
    if (localStorage.getItem('map')) {
      const coordinates = JSON.parse(localStorage.getItem('map'));
      coordinates.forEach(position => {
        const cube = new Block(position);
        cubes.push(cube);
        scene.add(cube.mesh);
        cubesFlag[position.z + 50][position.x + 50] = true;
      });
    }
    let isEditMode = false;
    let isDiveMode = false;
    
    let cameraDistance = 8;

    let currentState = viewMode.birdsEye; 
    let weapon = weaponMode.main;

    const cameraBaseHeight = 20;
    const cameraEditHeight = 70;

    // DEBUG
    const gridHelper = new THREE.GridHelper(1000, 1000);
    gridHelper.position.y = 1;
    // scene.add(gridHqelper);

    // ライトを付けます
    const ambientLight = new THREE.AmbientLight( 0x242424 );
		scene.add(ambientLight);
    
    // 描画用の部品を作って
    const renderer = new THREE.WebGLRenderer({
        alpha: true
    });
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement ); // 画面に部品を登録します
    
    // カメラを作って
    const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 10000 );
    camera.position.set(0, cameraBaseHeight, 0); // カメラを上（y方向）に飛ばして
    camera.lookAt(new THREE.Vector3(0,0,0)); // 下（原点）を見る
    scene.add(camera); // シーンに登録します

    // マップを描画するための部品を作って
    const mapRenderer = new THREE.WebGLRenderer({
        alpha: true
    });
    mapRenderer.setSize( window.innerWidth, window.innerHeight );
    mapRenderer.domElement.id = 'map';
    // Step.5 画面に部品を登録します　document.body.appendChild( mapRenderer.domElement );
    document.body.appendChild( mapRenderer.domElement ); 

    mapRenderer.domElement.style.width = "250px"; // マップを表示するパーツなのでちっさくしましょう
    mapRenderer.domElement.style.height = "250px";

    // マップを表示するためのカメラも作って
    const mapCamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 10000 );
    mapCamera.position.set(0, 30, 0);
    mapCamera.lookAt(new THREE.Vector3(0, 0, 0));
    scene.add(mapCamera); // シーンに登録しよう

    // player
    const geometry = new THREE.BoxGeometry( 0.8, 0.8, 1.6 ); // 形状の指定
    const material = new THREE.MeshBasicMaterial( { color: 0x555749 } ); // 表面の素材を指定（テクスチャ―もこれ
    const player = new THREE.Mesh( geometry, material ); // ポリゴンメッシュ（略してメッシュ）。多角形の面の集合体
    player.position.set(0, floorY, 0); // 位置を決めてー
    player.castShadow = true; // 影を出すようにしてー
    player.receiveShadow = true; // 影を受けるようにして―
    // TODO: 自キャラのインク（？）の色を決定
    player.inkColor = 0x6464ff;

    // Step.1 シーンに追加する scene.add( player );
    scene.add( player );  

    player.bb = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3()); // 接触判定用のBoundingBox（輪郭の箱）を用意
    player.bb.setFromObject(player);  // BoundingBoxとMeshと紐づける！

    // wall 作ろうかと思ったけど，まあいっか

    // sample cube
    if(cubes.length === 0) {
      const cube = new Block({x:2, y: floorY, z: -2}); // オリジナルのCubeを作る呪文
      cubesFlag[48][52] = true; // cubeがその位置に登録されているかどうかどうかの設定
      cubes.push(cube);
      // Step.2 作ったらシーンにcubeのメッシュを登録しよう
      scene.add( cube.mesh );
    }

    // Floor　床（平面）を作ろう
    // TODO: 実験
    const floorGeometry = new THREE.PlaneGeometry(100, 100, 100, 100).toNonIndexed();

    // 一つのセグメントごとにデータが6つ（3角形2つだから）
    const positionAttribute = floorGeometry.getAttribute('position');

    const colors = [];
    const color = new THREE.Color();

    for (let i = 0; i < positionAttribute.count; i += 6) {
      color.setHex(0xdddddd);
      const alpha = 1;

      colors.push(color.r, color.g, color.b, alpha);
      colors.push(color.r, color.g, color.b, alpha);
      colors.push(color.r, color.g, color.b, alpha);

      colors.push(color.r, color.g, color.b, alpha);
      colors.push(color.r, color.g, color.b, alpha);
      colors.push(color.r, color.g, color.b, alpha);

    }

    floorGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 4));

    const floorMaterial = new THREE.MeshBasicMaterial({
      vertexColors: true,
      transparent: true,
      side: THREE.DoubleSide
    });

    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.receiveShadow = true;
    floor.rotation.x = Math.PI / -2; // 平面を作ると縦に出来上がるので，回転させて床にする（なお，三角関数を利用）
    scene.add( floor ); // やっぱりシーンに追加する

    floor.bb = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3()); // 接触判定用のBoundingBox（輪郭の箱）を用意
    floor.bb.setFromObject(floor);  // BoundingBoxとMeshと紐づける！


    function isPlayerArea(position, color = 0x9696ff) {
      const c = new THREE.Color();
      c.setHex(color);
      const a = 1;
      const baseIndex = ((Math.floor(position.x) + 50) * 24) + (((Math.floor(position.z)) + 50) * 2400);

      let index = baseIndex - 2400 - 24;
      for (let i = index; i < index + ((6 * 4) * 2); i += 4) {
        if (colors[i + 0] !== c.r) return false;
        if (colors[i + 1] !== c.g) return false;
        if (colors[i + 2] !== c.b) return false;
      }
      index = baseIndex - 24;
      for (let i = index; i < index + ((6 * 4) * 2); i += 4) {
        if (colors[i + 0] !== c.r) return false;
        if (colors[i + 1] !== c.g) return false;
        if (colors[i + 2] !== c.b) return false;
      }

      return true;
    }

    function updateFloor(position, color = 0x9696ff) {
      const c = new THREE.Color();
      c.setHex(color);
      const a = 1;
      const baseIndex = ((Math.floor(position.x) + 50) * 24) + (((Math.floor(position.z)) + 50) * 2400);


      let index = baseIndex - 4800 - 24;
      for (let i = index; i < index + ((6 * 4) * 2); i += 4) {
        colors[i + 0] = c.r;
        colors[i + 1] = c.g;
        colors[i + 2] = c.b;
        colors[i + 3] = a;
      }

      index = baseIndex -2400 - 24 - 24;
      for (let i = index; i < index + ((6 * 4) * 4); i += 4) {
        colors[i + 0] = c.r;
        colors[i + 1] = c.g;
        colors[i + 2] = c.b;
        colors[i + 3] = a;
      }

      index = baseIndex - 24 - 24;
      for (let i = index; i < index + ((6 * 4) * 4); i += 4) {
        colors[i + 0] = c.r;
        colors[i + 1] = c.g;
        colors[i + 2] = c.b;
        colors[i + 3] = a;
      }

      index = baseIndex + 2400 - 24;
      for (let i = index; i < index + ((6 * 4) * 2); i += 4) {
        colors[i + 0] = c.r;
        colors[i + 1] = c.g;
        colors[i + 2] = c.b;
        colors[i + 3] = a;
      }


      floor.geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 4));
      floor.geometry.colorsNeedUpdate = true;
    }


    // 動いた時に線を描きたい場合は呼び出す関数
    function drawLine() {
      points.push(new THREE.Vector3(player.position.x, player.position.y, player.position.z));
      line.geometry = new THREE.BufferGeometry().setFromPoints(points)
    }


    // 各種ボタン連打・弾丸発射間隔の計測用変数
    const interval = {
      triger: 0,
      lTriger: 0,
      x: 0,
      rs: 0,
      rb: 0
    }

    function animate() {
      requestAnimationFrame( animate );

      const padList = navigator.getGamepads();
      if(padList[0]) {
        const pad = padList[0];
        const xBtn = pad.buttons[config.button.x].pressed;
        const yBtn = pad.buttons[config.button.y].pressed;
        const rbBtn = pad.buttons[config.button.rb].pressed;
        const backBtn = pad.buttons[config.button.back].pressed;
        const startBtn = pad.buttons[config.button.start].pressed;
        const rTriger = pad.buttons[config.button.rt].pressed; 
        const upDown = pad.axes[config.stick.leftY];
        const LR = pad.axes[config.stick.rightX];
        const lTriger = pad.buttons[config.button.lt].pressed;
        const lStick = pad.buttons[config.button.lStick].pressed;
        const rStick = pad.buttons[config.button.rStick].pressed;

        // TODO: playerをクラス分けして，move(speed, rotation)で制御したほうがよさそう
        // 移動
        if(!isEditMode) {
          const rt = document.querySelector('#rTriger')
          // ボールを投げる
          interval.triger--;
          if(interval.triger === 0) rt.classList.remove('cooldown');
          interval.rb--;
          if(rTriger) {
            if(interval.triger < 0) {
              if(weapon !== weaponMode.main) weapon = weaponMode.main;
              if(weapon === weaponMode.main && !isDiveMode) {
                shoot();
                interval.triger = 30; // 連射速度を制御
                rt.classList.add('cooldown');
              }
            }
            if(rbBtn) document.querySelector('#rButton').classList.remove('active');
          } else {
            if(rbBtn) {
              document.querySelector('#rButton').classList.add('active');
              if (interval.rb < 0) {
                if(weapon !== weaponMode.sub1) weapon = weaponMode.sub1;
                if(weapon === weaponMode.sub1) {
                  subWeapon1();
                  interval.rb = 30;
                }
              }
            } else {
              document.querySelector('#rButton').classList.remove('active');
            }
          }
        
          // 潜行 TODO: 潜っているときの自機の位置が不明。
          if(lTriger) {
            if(interval.lTriger < 0 && isPlayerArea(player.position)) {
              document.querySelector('#dive').classList.add('active');
              player.position.y = -0.35;
              player.material.color.setHex(0x5557ff);
              isDiveMode = true;
            } else if(isDiveMode && !isPlayerArea(player.position)) {
              isDiveMode = false;
              document.querySelector('#dive').classList.remove('active');
              document.querySelector('#dive').classList.add('penalty');
              player.material.color.setHex(0x555749);
              interval.lTriger = 30; // 連射速度を制御
              player.position.y = floorY;
            }
          } else if(!lTriger && !isDiveMode) {
            interval.lTriger--;
            player.position.y = floorY;
          } else if (!lTriger && isDiveMode) { // TODO: いる？
            isDiveMode = false;
            document.querySelector('#dive').classList.remove('active');
            interval.lTriger = 30; // 連射速度を制御
            if(interval.lTriger === 30)document.querySelector('#dive').classList.add('cooldown');
            player.position.y = floorY;
            player.material.color.setHex(0x555749);
          }

          if(interval.lTriger === 0) {
            const ui = document.querySelector('#dive');
            ui.classList.remove('cooldown');
            ui.classList.remove('penalty');
          }

          // 移動　TODO: 撃っている間は動きを鈍らせてもいいかもね
          if(upDown < -0.3 ) {
            let speed = 0.1 * upDown;
            if (isDiveMode) speed *= 2;
            player.translateZ(speed);
            document.querySelector('#lStick').classList.add("active");
          } else if(upDown > 0.3) {
            let speed = 0.1 * upDown;
            if (isDiveMode) speed *= 2;
            player.translateZ(speed);
            document.querySelector('#lStick').classList.add("active");
          } else {
            document.querySelector('#lStick').classList.remove("active");
          }
          
          if(LR < -0.3 || 0.3 < LR) {
            document.querySelector('#rStick').classList.add("active");
            const rad = 0.02 * LR;
            player.rotation.y -= rad;
          } else {
            document.querySelector('#rStick').classList.remove("active");
          }

          switch(currentState) {
            case viewMode.birdsEye:
              camera.position.x = player.position.x;
              camera.position.z = player.position.z;
              // TODO: 入れるか迷う（なんか酔いそう？）
              // camera.rotation.z = player.rotation.y;
              break;
              case viewMode.thirdPerson:
              camera.rotation.y = player.rotation.y
              
              const rad = -player.rotation.y + (90 * Math.PI / 180);
              camera.position.y = player.position.y + 2;
              camera.position.x = player.position.x + cameraDistance * Math.cos(rad);
              camera.position.z = player.position.z + cameraDistance * Math.sin(rad);
              
              break;
            case viewMode.firstPerson:
              camera.position.x = player.position.x;
              camera.position.z = player.position.z;
              if (isDiveMode) camera.position.y = 0.1;
              else camera.position.y = player.position.y;
              
              camera.rotation.y = player.rotation.y;
              break;
          }
        }

        // 視点変更
        interval.rs--;
        if(rStick) {
          if (interval.rs < 0 && !isEditMode) {
            interval.rs = 20;
            currentState = (currentState + 1) % 3;
            setCamera(currentState);
          }
        }

        // モード変更 EDIT
        interval.x--;
        if(xBtn) {
          if (interval.x < 0) {
            interval.x = 20;

            if(isEditMode) {
              isEditMode = false;
              setCamera(currentState);
            } else { 
              isEditMode = true;
              // TODO: モードに応じた視点に変更
              camera.position.y = cameraEditHeight;
              camera.position.x = 0;
              camera.position.z = 0;
              camera.lookAt(0, 0, 0);
            } 
          }
        }


        if(startBtn) {
          alert('マップを保存しました！');
          const coordinates = cubes.map(cube => cube.position);
          localStorage.setItem('map', JSON.stringify(coordinates));
        } 
        if(backBtn) {
          const result = window.confirm('保存されたマップデータを削除しますか？');
          if(result) {
            localStorage.removeItem('map');
            alert('保存されたマップデータを消去しました')
            location.reload();
          }
        }
      }
      
      // 床の範囲を越えたら重力の影響を受けます。
      if(player.position.x < -50 || 50 < player.position.x || player.position.z < -50 || 50 < player.position.z) {
        player.position.y -= 0.98;
      }

      player.bb.copy(player.geometry.boundingBox).applyMatrix4(player.matrixWorld); // 動くたびにバウンディングボックスをコピー
      cubes.forEach(cube => { // 一つ一つのキューブを取り出して，
        // Step.6 衝突の検知 cube.collision(player.bb);
        const result = cube.collision(player.bb, player.inkColor);

        if (result) {
          const padList = navigator.getGamepads();
          if (padList[0]) {
            padList[0].vibrationActuator.playEffect('dual-rumble', {
              startDelay: 0,
              duration: 100,
              weakMagnitude: 1.0,
              strongMagnitude: 1.0,
            });
          }

          // ぶつかったらしばらく玉が撃てないように
          interval.triger = 30;
          interval.rb = 30;

          updateFloor(cube.position, 0xff6464);
        }
      })

      mapCamera.position.x = player.position.x;
      mapCamera.position.z = player.position.z;


      balls.forEach((ball, i) =>{
        if(currentState === viewMode.firstPerson) {
          ball.mesh.material.transparent = true;
          ball.mesh.material.opacity = 0.5;
        } else {
          ball.mesh.material.transparent = false;
          ball.mesh.material.opacity = 1.0;
        }
        ball.move();
        cubes.forEach(cube => {
          if(ball.collision(cube.boundingBox, cube)) {
            cube.mesh.material.color.setHex(ball.color);
            this.isNotHit = false;
            updateFloor(cube.mesh.position);
          }
        });

        // 床も塗ろう
        if(ball.collision(floor.bb)) {
          updateFloor(ball.mesh.position);
        }
        
        if(!ball.isNotHit) {
          balls.splice(i, 1);
          scene.remove(ball.mesh);
          ball.mesh.material.dispose();
          ball.mesh.geometry.dispose();
        }
      });
      balls = balls.filter(b => b.isNotHit);

      renderer.render( scene, camera );
      mapRenderer.render( scene, mapCamera);
    }
    
    // 一瞬一瞬，再描画し続ける
    animate();
  
    function shoot() {
      const ball = new Ball(player); // オリジナルのCubeを作る呪文
      scene.add( ball.mesh );
      balls.push(ball);
      // player.translateZ(0.3); // 反動で後退（酔いそうなので削除）
    }
    function subWeapon1() {
      updateFloor(player.position);
    }

    function setCamera(state) {
      let title = document.querySelector("#view h2");
      switch(state) {
        case viewMode.birdsEye:
          title.innerHTML = "Bird's Eye";
          camera.position.y = cameraBaseHeight;
          camera.rotation.y = 0;
          camera.position.z = player.position.z;
          camera.lookAt(player.position.x, player.position.y, player.position.z);
          break;
        case viewMode.thirdPerson:
          title.innerHTML = "Third Person";
          camera.rotation.y = player.rotation.y;
          
          console.log(player.rotation.y);
          const rad = -player.rotation.y + (90 * Math.PI / 180);
          console.log(player.rotation.y, rad);

          camera.position.y = player.position.y + 2;
          camera.position.x = player.position.x + Math.abs(cameraDistance * Math.cos(rad));
          camera.position.z = player.position.z + Math.abs(cameraDistance * Math.sin(rad));
          
          camera.lookAt(player.position.x, player.position.y + 2, player.position.z - 2);
          break;
        case viewMode.firstPerson:
          title.innerHTML = "First Person";
          camera.position.y = player.position.y;
          camera.position.z = player.position.z;
          camera.rotation.y = player.rotation.y;
          camera.lookAt(player.position.x, floorY, player.position.z - 1);
          if (isDiveMode) {
            camera.position.y = 0.1; // TODO: カメラの位置を確認潜っているときは深く
            camera.lookAt(player.position.x, 0.1, player.position.z - 1); 
          }
          break;
      }
    }

    const raycaster = new THREE.Raycaster();
    window.addEventListener('click', (event) => {
      clickHandler((mesh, x, z) => {
        scene.remove(mesh);
        mesh.material.dispose();
        mesh.geometry.dispose();

        cubesFlag[z][x] = false;
      });
    }, false);

    function clickHandler(meshClear) {
      if(!isEditMode) return;
      // レイキャスト = マウス位置からまっすぐに伸びる光線ベクトルを生成
      raycaster.setFromCamera(mouse, camera);

      // その光線とぶつかったオブジェクトを得る
      const intersects = raycaster.intersectObjects(scene.children);

      if(intersects.length > 0){
        console.log(intersects[0].object === floor)
        
        const point = intersects[0].point;
      
        // Grid上に置くため，切り捨てしておく
        const x = Math.floor(point.x);
        const z = Math.floor(point.z);

        // TODO: x + 50とか避けて変数に。
        if(cubesFlag[z + 50][x + 50]) {
          if(intersects[0].object === floor) return;
          // meshがあったら削除
          meshClear(intersects[0].object, x + 50, z + 50);
          return;
        }

        cubesFlag[z + 50][x + 50] = true;

        // console.log(`${x}, ${z}`);
        const cube = new Block({x: x, y: floorY, z: z});
        scene.add( cube.mesh );
        cubes.push(cube);
      }
    }


    let isDrag = false;
    window.addEventListener('mousedown', event => {
      isDrag = true;
    }, false)

    window.addEventListener('mouseup', event => {
      isDrag = false;
    }, false)

    // canvas 要素の参照を取得する
    const canvas = document.querySelector('canvas');
    // マウス座標管理用のベクトルを作成
    const mouse = new THREE.Vector2();
    canvas.addEventListener('mousemove', (event) => {
      const element = event.currentTarget;
      // canvas要素上のXY座標
      const x = event.clientX - element.offsetLeft;
      const y = event.clientY - element.offsetTop;
      // canvas要素の幅・高さ
      const w = element.offsetWidth;
      const h = element.offsetHeight;

      // -1〜+1の範囲で現在のマウス座標を登録する
      mouse.x = ( x / w ) * 2 - 1;
      mouse.y = -( y / h ) * 2 + 1;

      if (isDrag) {
        clickHandler(() => {});
      }
    }, false);


    /* ゲームパッド関連 */
    // 接続処理
    window.addEventListener("gamepadconnected", function(e) {
      console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",
        e.gamepad.index, e.gamepad.id,
        e.gamepad.buttons.length, e.gamepad.axes.length);
    });

    // 切断処理
    window.addEventListener("gamepaddisconnected", function(e) {
      console.log("Gamepad disconnected from index %d: %s",
        e.gamepad.index, e.gamepad.id);
    });

    loadUI();
  </script>
</body>
</html>